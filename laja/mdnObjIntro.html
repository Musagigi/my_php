<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width"
		/>
		<title>Object-oriented JavaScript example</title>
	</head>

	<body>
		<h1 class="test1">Tst</h1>

		<script>
			const person = {
				name: ["Bob", "Smith"],
				age: 32,
				gender: "male",
				interests: ["music", "skiing"],
				bio() {
					console.log(
						this.name[0] +
							" " +
							this.name[1] +
							" is " +
							this.age +
							" years old. He likes " +
							this.interests[0] +
							" and " +
							this.interests[1] +
							"."
					);
				},
				greeting() {
					console.log("Hi! I'm " + this.name[0] + ".");
				},
			};

			const pers2 = {
				name: ["ivan", "ivanov"],
				greeting() {
					console.log("Hi! " + this.name[0] + ".");
				},
				__proto__: person,
			};
			pers2.greeting();

			// Свойства и методы определяются в свойстве prototype функции-конструктора объектов, а не в самих объектах

			// Каждая функция-конструктор имеет свойство prototype, значением которого является объект, содержащий свойство constructor. Это свойство constructor указывает на исходную функцию-конструктор.

			//Полиморфизм - Это особенность — когда метод имеет одно и то же имя, но разную реализацию в разных классах. Когда метод в подклассе заменяет реализацию суперкласса, мы говорим, что подкласс переопределяет версию в суперклассе.
			function Person(first, last, age, gender, interests) {
				this.test = 10;
				this.name = {
					first,
					last,
				};
				this.age = age;
				this.gender = gender;
				this.interests = interests;
				this.sayHello = function () {
					console.log(this.name.first + " hello");
				};
			}

			Person.prototype.greeting = function () {
				console.log("Hi! I'm " + this.name.first + ".");
			};
			console.log(Person.prototype);

			let person1 = new Person("ivan", "ivanov", 32, "male", [
				"music",
				"skiing",
			]);
			person1.sayHello();
			person1.greeting();
			person1.myName = "person1";
			console.log(person1);
			console.log(person1.__proto__);

			// метод Object. create() создаёт новый объект с указанным прототипом и свойствами
			let person2 = Object.create(person1);
			person2.myName = "person2";
			console.log(person2);
			console.log(person2.age); // наследует от person1, берет его знаечение

			function Teacher(first, last, age, gender, interests, subject) {
				// наследуем св-ва от Person, а не переопределяем свои
				Person.call(this, first, last, age, gender, interests);

				this.subject = subject;
			}

			// Нам нужно заставить Teacher() наследовать методы, определённые на прототипе Person()
			Teacher.prototype = Object.create(Person.prototype);

			// Указываем конструктор на самого себя, а так будет Person
			// Teacher.prototype.constructor = Teacher; - можно так, но лучше как ниже
			Object.defineProperty(Teacher.prototype, "constructor", {
				value: Teacher,
				enumerable: false, // false, чтобы данное свойство не появлялось в цикле for in
				writable: true,
			});
			console.log(Teacher.prototype);
			let tea = new Teacher();
			console.log(tea.test);

			function Te() {}
			Te.prototype = Object.create(Teacher.prototype);
			Te.prototype.constructor = Te;
			console.log(Te.prototype);
		</script>
	</body>
</html>
